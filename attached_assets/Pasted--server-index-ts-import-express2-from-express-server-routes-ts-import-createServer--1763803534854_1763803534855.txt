// server/index.ts
import express2 from "express";

// server/routes.ts
import { createServer } from "http";

// server/storage.ts
import { randomUUID } from "crypto";
var MemStorage = class {
  queries;
  salesOrders;
  workOrders;
  invoices;
  inventoryItems;
  constructor() {
    this.queries = /* @__PURE__ */ new Map();
    this.salesOrders = this.initSalesOrders();
    this.workOrders = this.initWorkOrders();
    this.invoices = this.initInvoices();
    this.inventoryItems = this.initInventoryItems();
  }
  // Query operations
  async createQuery(insertQuery) {
    const id = randomUUID();
    const query = {
      id,
      ...insertQuery,
      generatedSql: null,
      aiInterpretation: null,
      resultData: null,
      status: "processing",
      errorMessage: null,
      executionTimeMs: null,
      createdAt: /* @__PURE__ */ new Date()
    };
    this.queries.set(id, query);
    return query;
  }
  async getQuery(id) {
    return this.queries.get(id);
  }
  async updateQuery(id, updates) {
    const query = this.queries.get(id);
    if (!query) return void 0;
    const updated = { ...query, ...updates };
    this.queries.set(id, updated);
    return updated;
  }
  async getRecentQueries(limit = 5) {
    return Array.from(this.queries.values()).sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime()).slice(0, limit);
  }
  async getQueryHistory() {
    return Array.from(this.queries.values()).sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime());
  }
  // Dashboard metrics
  async getDashboardMetrics() {
    const totalSales = this.salesOrders.filter((o) => o.status === "completed").reduce((sum, o) => sum + parseFloat(o.totalAmount), 0);
    const pendingOrders = this.salesOrders.filter((o) => o.status === "pending").length;
    const activeWorkOrders = this.workOrders.filter((w) => w.status === "in-progress").length;
    const overdueInvoices = this.invoices.filter((i) => {
      return i.status === "pending" && new Date(i.dueDate) < /* @__PURE__ */ new Date();
    }).length;
    return {
      totalSales,
      pendingOrders,
      activeWorkOrders,
      overdueInvoices
    };
  }
  // Query templates
  async getQueryTemplates() {
    return [
      {
        id: "sales-last-quarter",
        category: "Sales Analytics",
        title: "Last Quarter Sales",
        description: "View sales performance for the previous quarter",
        exampleQuery: "What are our sales figures for the last quarter?",
        icon: "chart"
      },
      {
        id: "delayed-work-orders",
        category: "Work Orders",
        title: "Delayed Work Orders",
        description: "Find all work orders that are behind schedule",
        exampleQuery: "Show me all delayed work orders",
        icon: "alert"
      },
      {
        id: "pending-invoices",
        category: "Invoice Processing",
        title: "Pending Invoices",
        description: "List all invoices awaiting payment",
        exampleQuery: "Show all pending invoices",
        icon: "file"
      },
      {
        id: "low-inventory",
        category: "Inventory Status",
        title: "Low Stock Items",
        description: "Items below reorder level",
        exampleQuery: "Which inventory items are running low?",
        icon: "package"
      },
      {
        id: "top-customers",
        category: "Sales Analytics",
        title: "Top Customers",
        description: "Customers with highest order values",
        exampleQuery: "Who are our top 5 customers by total sales?",
        icon: "users"
      },
      {
        id: "overdue-invoices",
        category: "Invoice Processing",
        title: "Overdue Invoices",
        description: "Invoices past their due date",
        exampleQuery: "Show overdue invoices",
        icon: "alert-circle"
      }
    ];
  }
  // Mock EBS data getters
  async getSalesOrders() {
    return this.salesOrders;
  }
  async getWorkOrders() {
    return this.workOrders;
  }
  async getInvoices() {
    return this.invoices;
  }
  async getInventoryItems() {
    return this.inventoryItems;
  }
  // Execute SQL - enhanced mock implementation with basic SQL parsing
  async executeSqlQuery(sql2) {
    const lowerSql = sql2.toLowerCase().trim();
    if (!lowerSql.startsWith("select")) {
      throw new Error("Only SELECT queries are supported");
    }
    let data = [];
    let tableName = "";
    if (lowerSql.includes("sales_orders")) {
      data = [...this.salesOrders];
      tableName = "sales_orders";
    } else if (lowerSql.includes("work_orders")) {
      data = [...this.workOrders];
      tableName = "work_orders";
    } else if (lowerSql.includes("invoices")) {
      data = [...this.invoices];
      tableName = "invoices";
    } else if (lowerSql.includes("inventory_items")) {
      data = [...this.inventoryItems];
      tableName = "inventory_items";
    } else {
      throw new Error("No valid table found in query. Supported tables: sales_orders, work_orders, invoices, inventory_items");
    }
    try {
      data = this.applyWhereConditions(data, sql2);
      data = this.applyOrderBy(data, sql2);
      data = this.applyLimit(data, sql2);
      return data;
    } catch (error) {
      throw new Error(`SQL execution error on ${tableName}: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  applyWhereConditions(data, sql2) {
    const whereMatch = sql2.match(/WHERE\s+(.+?)(?:ORDER BY|LIMIT|TOP|$)/i);
    if (!whereMatch) return data;
    const whereClause = whereMatch[1].trim();
    return data.filter((row) => {
      if (whereClause.match(/status\s*=\s*['"](\w+)['"]/i)) {
        const statusMatch = whereClause.match(/status\s*=\s*['"](\w+)['"]/i);
        if (statusMatch && row.status !== statusMatch[1]) return false;
      }
      if (whereClause.match(/priority\s*=\s*['"](\w+)['"]/i)) {
        const priorityMatch = whereClause.match(/priority\s*=\s*['"](\w+)['"]/i);
        if (priorityMatch && row.priority !== priorityMatch[1]) return false;
      }
      if (whereClause.match(/region\s*=\s*['"](\w+)['"]/i)) {
        const regionMatch = whereClause.match(/region\s*=\s*['"](\w+)['"]/i);
        if (regionMatch && row.region !== regionMatch[1]) return false;
      }
      if (whereClause.match(/due_date\s*<\s*(?:GETDATE|CURRENT_DATE|NOW)/i)) {
        if (row.dueDate) {
          const dueDate = new Date(row.dueDate);
          if (dueDate >= /* @__PURE__ */ new Date()) return false;
        }
      }
      if (whereClause.match(/scheduled_date\s*<\s*(?:GETDATE|CURRENT_DATE|NOW)/i)) {
        if (row.scheduledDate) {
          const schedDate = new Date(row.scheduledDate);
          if (schedDate >= /* @__PURE__ */ new Date()) return false;
        }
      }
      if (whereClause.match(/quantity_on_hand\s*<=\s*reorder_level/i)) {
        if (row.quantityOnHand && row.reorderLevel) {
          if (row.quantityOnHand > row.reorderLevel) return false;
        }
      }
      if (whereClause.match(/order_date\s*>=\s*DATEADD\(quarter,\s*-1/i)) {
        if (row.orderDate) {
          const orderDate = new Date(row.orderDate);
          const threeMonthsAgo = /* @__PURE__ */ new Date();
          threeMonthsAgo.setMonth(threeMonthsAgo.getMonth() - 3);
          if (orderDate < threeMonthsAgo) return false;
        }
      }
      if (whereClause.match(/status\s*=\s*['"]delayed['"]\s+OR/i)) {
        const isDelayed = row.status === "delayed";
        const isOverdue = row.status === "in-progress" && row.scheduledDate && new Date(row.scheduledDate) < /* @__PURE__ */ new Date();
        if (!isDelayed && !isOverdue) return false;
      }
      return true;
    });
  }
  applyOrderBy(data, sql2) {
    const orderMatch = sql2.match(/ORDER BY\s+(\w+)(?:\s+(ASC|DESC))?/i);
    if (!orderMatch) return data;
    const column = this.mapColumnName(orderMatch[1]);
    const direction = (orderMatch[2] || "ASC").toUpperCase();
    return data.sort((a, b) => {
      const aVal = a[column];
      const bVal = b[column];
      if (aVal === null || aVal === void 0) return 1;
      if (bVal === null || bVal === void 0) return -1;
      if (aVal instanceof Date || typeof aVal === "string" && !isNaN(Date.parse(aVal))) {
        const aDate = new Date(aVal).getTime();
        const bDate = new Date(bVal).getTime();
        return direction === "DESC" ? bDate - aDate : aDate - bDate;
      }
      if (typeof aVal === "number" || !isNaN(parseFloat(aVal))) {
        const aNum = parseFloat(aVal);
        const bNum = parseFloat(bVal);
        return direction === "DESC" ? bNum - aNum : aNum - bNum;
      }
      const comparison = String(aVal).localeCompare(String(bVal));
      return direction === "DESC" ? -comparison : comparison;
    });
  }
  applyLimit(data, sql2) {
    const limitMatch = sql2.match(/LIMIT\s+(\d+)/i);
    if (limitMatch) {
      return data.slice(0, parseInt(limitMatch[1]));
    }
    const topMatch = sql2.match(/SELECT\s+TOP\s+(\d+)/i);
    if (topMatch) {
      return data.slice(0, parseInt(topMatch[1]));
    }
    return data;
  }
  mapColumnName(sqlColumn) {
    const mapping = {
      "order_id": "orderId",
      "order_number": "orderNumber",
      "customer_name": "customerName",
      "order_date": "orderDate",
      "total_amount": "totalAmount",
      "sales_rep": "salesRep",
      "work_order_id": "workOrderId",
      "work_order_number": "workOrderNumber",
      "assigned_to": "assignedTo",
      "scheduled_date": "scheduledDate",
      "completion_date": "completionDate",
      "invoice_id": "invoiceId",
      "invoice_number": "invoiceNumber",
      "vendor_name": "vendorName",
      "invoice_date": "invoiceDate",
      "due_date": "dueDate",
      "payment_terms": "paymentTerms",
      "item_id": "itemId",
      "item_code": "itemCode",
      "item_name": "itemName",
      "quantity_on_hand": "quantityOnHand",
      "unit_price": "unitPrice",
      "reorder_level": "reorderLevel"
    };
    return mapping[sqlColumn.toLowerCase()] || sqlColumn;
  }
  // Initialize mock data
  initSalesOrders() {
    const statuses = ["pending", "completed", "cancelled", "processing"];
    const regions = ["North", "South", "East", "West"];
    const customers = [
      "Acme Corporation",
      "TechFlow Industries",
      "Global Solutions Inc",
      "Summit Enterprises",
      "Pinnacle Systems",
      "Vertex Group",
      "Horizon Technologies",
      "Meridian Corp",
      "Atlas Industries",
      "Zenith Solutions"
    ];
    const salesReps = ["John Smith", "Sarah Johnson", "Mike Davis", "Emily Chen", "Robert Wilson"];
    const orders = [];
    const baseDate = /* @__PURE__ */ new Date("2024-01-01");
    for (let i = 1; i <= 50; i++) {
      const orderDate = new Date(baseDate.getTime() + Math.random() * 365 * 24 * 60 * 60 * 1e3);
      orders.push({
        orderId: `SO-${1e3 + i}`,
        orderNumber: `ORD-2024-${String(i).padStart(4, "0")}`,
        customerName: customers[Math.floor(Math.random() * customers.length)],
        orderDate,
        totalAmount: (Math.random() * 5e4 + 5e3).toFixed(2),
        status: statuses[Math.floor(Math.random() * statuses.length)],
        region: regions[Math.floor(Math.random() * regions.length)],
        salesRep: salesReps[Math.floor(Math.random() * salesReps.length)]
      });
    }
    return orders;
  }
  initWorkOrders() {
    const statuses = ["pending", "in-progress", "completed", "delayed", "cancelled"];
    const priorities = ["low", "medium", "high", "urgent"];
    const departments = ["Manufacturing", "Maintenance", "Quality Control", "Production", "Assembly"];
    const assignees = ["Team Alpha", "Team Beta", "Team Gamma", "Team Delta", "Team Epsilon"];
    const orders = [];
    const baseDate = /* @__PURE__ */ new Date("2024-01-01");
    for (let i = 1; i <= 40; i++) {
      const scheduledDate = new Date(baseDate.getTime() + Math.random() * 180 * 24 * 60 * 60 * 1e3);
      const hasCompleted = Math.random() > 0.5;
      orders.push({
        workOrderId: `WO-${2e3 + i}`,
        workOrderNumber: `WRK-2024-${String(i).padStart(4, "0")}`,
        description: `Work order for ${departments[Math.floor(Math.random() * departments.length)]} operations`,
        assignedTo: assignees[Math.floor(Math.random() * assignees.length)],
        status: statuses[Math.floor(Math.random() * statuses.length)],
        priority: priorities[Math.floor(Math.random() * priorities.length)],
        scheduledDate,
        completionDate: hasCompleted ? new Date(scheduledDate.getTime() + Math.random() * 30 * 24 * 60 * 60 * 1e3) : null,
        department: departments[Math.floor(Math.random() * departments.length)]
      });
    }
    return orders;
  }
  initInvoices() {
    const statuses = ["pending", "paid", "overdue", "cancelled"];
    const vendors = [
      "Office Supplies Co",
      "Industrial Parts Ltd",
      "Tech Equipment Inc",
      "Building Materials Corp",
      "Energy Solutions",
      "Logistics Partners",
      "Manufacturing Tools Ltd",
      "Safety Equipment Co",
      "IT Services Inc"
    ];
    const paymentTerms = ["Net 30", "Net 60", "Net 90", "Due on Receipt", "2/10 Net 30"];
    const invoices2 = [];
    const baseDate = /* @__PURE__ */ new Date("2024-01-01");
    for (let i = 1; i <= 35; i++) {
      const invoiceDate = new Date(baseDate.getTime() + Math.random() * 300 * 24 * 60 * 60 * 1e3);
      const daysToAdd = Math.random() > 0.5 ? 30 : 60;
      const dueDate = new Date(invoiceDate.getTime() + daysToAdd * 24 * 60 * 60 * 1e3);
      invoices2.push({
        invoiceId: `INV-${3e3 + i}`,
        invoiceNumber: `IV-2024-${String(i).padStart(4, "0")}`,
        vendorName: vendors[Math.floor(Math.random() * vendors.length)],
        invoiceDate,
        dueDate,
        amount: (Math.random() * 25e3 + 1e3).toFixed(2),
        status: statuses[Math.floor(Math.random() * statuses.length)],
        paymentTerms: paymentTerms[Math.floor(Math.random() * paymentTerms.length)]
      });
    }
    return invoices2;
  }
  initInventoryItems() {
    const categories = ["Raw Materials", "Finished Goods", "Components", "Tools", "Supplies"];
    const warehouses = ["Warehouse A", "Warehouse B", "Warehouse C", "Distribution Center"];
    const items = [];
    for (let i = 1; i <= 30; i++) {
      const quantity = Math.floor(Math.random() * 1e3);
      const reorderLevel = Math.floor(Math.random() * 200 + 50);
      items.push({
        itemId: `ITM-${4e3 + i}`,
        itemCode: `ITEM-${String(i).padStart(4, "0")}`,
        itemName: `Inventory Item ${i}`,
        category: categories[Math.floor(Math.random() * categories.length)],
        quantityOnHand: quantity,
        unitPrice: (Math.random() * 500 + 10).toFixed(2),
        reorderLevel,
        warehouse: warehouses[Math.floor(Math.random() * warehouses.length)]
      });
    }
    return items;
  }
};
var storage = new MemStorage();

// server/openai-service.ts
import OpenAI from "openai";
var openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });
var EBS_SCHEMA_CONTEXT = `
You are an expert SQL generator for Oracle E-Business Suite (EBS) database queries.

Available Tables and Schemas:

1. sales_orders
   - order_id (VARCHAR, Primary Key)
   - order_number (VARCHAR)
   - customer_name (TEXT)
   - order_date (TIMESTAMP)
   - total_amount (DECIMAL)
   - status (VARCHAR) - values: 'pending', 'completed', 'cancelled', 'processing'
   - region (VARCHAR) - values: 'North', 'South', 'East', 'West'
   - sales_rep (TEXT)

2. work_orders
   - work_order_id (VARCHAR, Primary Key)
   - work_order_number (VARCHAR)
   - description (TEXT)
   - assigned_to (TEXT)
   - status (VARCHAR) - values: 'pending', 'in-progress', 'completed', 'delayed', 'cancelled'
   - priority (VARCHAR) - values: 'low', 'medium', 'high', 'urgent'
   - scheduled_date (TIMESTAMP)
   - completion_date (TIMESTAMP, nullable)
   - department (VARCHAR)

3. invoices
   - invoice_id (VARCHAR, Primary Key)
   - invoice_number (VARCHAR)
   - vendor_name (TEXT)
   - invoice_date (TIMESTAMP)
   - due_date (TIMESTAMP)
   - amount (DECIMAL)
   - status (VARCHAR) - values: 'pending', 'paid', 'overdue', 'cancelled'
   - payment_terms (VARCHAR)

4. inventory_items
   - item_id (VARCHAR, Primary Key)
   - item_code (VARCHAR)
   - item_name (TEXT)
   - category (VARCHAR)
   - quantity_on_hand (INTEGER)
   - unit_price (DECIMAL)
   - reorder_level (INTEGER)
   - warehouse (VARCHAR)

Rules:
- Use standard SQL syntax
- Return only SELECT queries (no INSERT, UPDATE, DELETE)
- Use appropriate WHERE clauses for filtering
- Use ORDER BY for sorting results
- Limit results to reasonable numbers (e.g., TOP 10, LIMIT 20)
- Use CAST or CONVERT for date comparisons
- For "last quarter" use: WHERE order_date >= DATEADD(quarter, -1, GETDATE())
- For "delayed" work orders: WHERE status = 'delayed' OR (status = 'in-progress' AND scheduled_date < GETDATE())
- For "overdue" invoices: WHERE status = 'pending' AND due_date < GETDATE()
- For "low inventory": WHERE quantity_on_hand <= reorder_level
`;
function generateFallbackSQL(userQuestion) {
  const lowerQuestion = userQuestion.toLowerCase();
  if (lowerQuestion.includes("pending") && lowerQuestion.includes("sales")) {
    return {
      sql: "SELECT * FROM sales_orders WHERE status = 'pending' ORDER BY order_date DESC LIMIT 20",
      interpretation: "Showing all pending sales orders, ordered by date (newest first), limited to 20 results",
      confidence: 0.85
    };
  }
  if (lowerQuestion.includes("delayed") && lowerQuestion.includes("work")) {
    return {
      sql: "SELECT * FROM work_orders WHERE status = 'delayed' ORDER BY scheduled_date ASC LIMIT 20",
      interpretation: "Showing all delayed work orders, ordered by scheduled date (oldest first), limited to 20 results",
      confidence: 0.85
    };
  }
  if (lowerQuestion.includes("overdue") && lowerQuestion.includes("invoice")) {
    return {
      sql: "SELECT * FROM invoices WHERE status = 'pending' AND due_date < CURRENT_TIMESTAMP ORDER BY due_date ASC LIMIT 20",
      interpretation: "Showing all overdue invoices (pending invoices past their due date), ordered by due date (oldest first), limited to 20 results",
      confidence: 0.85
    };
  }
  if (lowerQuestion.includes("low") && lowerQuestion.includes("inventory")) {
    return {
      sql: "SELECT * FROM inventory_items WHERE quantity_on_hand <= reorder_level ORDER BY quantity_on_hand ASC LIMIT 20",
      interpretation: "Showing all inventory items below reorder level, ordered by quantity (lowest first), limited to 20 results",
      confidence: 0.85
    };
  }
  if (lowerQuestion.includes("sales")) {
    return {
      sql: "SELECT * FROM sales_orders ORDER BY order_date DESC LIMIT 20",
      interpretation: "Showing recent sales orders, ordered by date (newest first), limited to 20 results",
      confidence: 0.7
    };
  }
  if (lowerQuestion.includes("work")) {
    return {
      sql: "SELECT * FROM work_orders ORDER BY scheduled_date DESC LIMIT 20",
      interpretation: "Showing recent work orders, ordered by scheduled date (newest first), limited to 20 results",
      confidence: 0.7
    };
  }
  if (lowerQuestion.includes("invoice")) {
    return {
      sql: "SELECT * FROM invoices ORDER BY invoice_date DESC LIMIT 20",
      interpretation: "Showing recent invoices, ordered by date (newest first), limited to 20 results",
      confidence: 0.7
    };
  }
  if (lowerQuestion.includes("inventory")) {
    return {
      sql: "SELECT * FROM inventory_items ORDER BY quantity_on_hand ASC LIMIT 20",
      interpretation: "Showing inventory items, ordered by quantity (lowest first), limited to 20 results",
      confidence: 0.7
    };
  }
  return {
    sql: "SELECT * FROM sales_orders ORDER BY order_date DESC LIMIT 10",
    interpretation: "Showing recent sales orders as a default query",
    confidence: 0.5
  };
}
async function generateSQLWithContext(userQuestion, previousQueries) {
  try {
    let contextPrompt = EBS_SCHEMA_CONTEXT;
    if (previousQueries && previousQueries.length > 0) {
      contextPrompt += `

Recent query patterns for context:
`;
      previousQueries.slice(0, 3).forEach((pq, idx) => {
        contextPrompt += `${idx + 1}. Question: "${pq.question}"
   SQL: ${pq.sql}
`;
      });
    }
    const response = await openai.chat.completions.create({
      model: "gpt-5",
      messages: [
        {
          role: "system",
          content: `${contextPrompt}

Your task is to:
1. Understand the user's natural language question about Oracle EBS data
2. Generate an accurate, efficient SQL query
3. Provide a clear interpretation of what the query does
4. Assess your confidence in the generated query

Important:
- Use proper SQL syntax and best practices
- Consider performance and use appropriate indexes
- Return only SELECT statements
- Be specific about which tables and columns to query
- Handle common business terms (e.g., "last quarter", "overdue", "top customers")

Return JSON format:
{
  "sql": "SELECT ... FROM ... WHERE ...",
  "interpretation": "Clear, business-friendly explanation",
  "confidence": 0.95
}`
        },
        {
          role: "user",
          content: userQuestion
        }
      ],
      response_format: { type: "json_object" },
      max_completion_tokens: 2048
    });
    const result = JSON.parse(response.choices[0].message.content || "{}");
    if (!result.sql || !result.sql.trim().toUpperCase().startsWith("SELECT")) {
      throw new Error("Generated query must be a SELECT statement");
    }
    return {
      sql: result.sql.trim(),
      interpretation: result.interpretation || "Generated SQL query based on your question",
      confidence: Math.min(Math.max(result.confidence || 0.7, 0), 1)
    };
  } catch (error) {
    console.error("OpenAI SQL Generation Error:", error);
    if (error instanceof Error && (error.message.includes("429") || error.message.includes("quota"))) {
      console.log("OpenAI quota exceeded, using fallback SQL generator");
      return generateFallbackSQL(userQuestion);
    }
    throw new Error(`AI processing failed: ${error instanceof Error ? error.message : "Unknown error"}`);
  }
}

// shared/schema.ts
import { sql } from "drizzle-orm";
import { pgTable, text, varchar, timestamp, integer, decimal } from "drizzle-orm/pg-core";
import { createInsertSchema } from "drizzle-zod";
var queries = pgTable("queries", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  userQuestion: text("user_question").notNull(),
  generatedSql: text("generated_sql"),
  aiInterpretation: text("ai_interpretation"),
  resultData: text("result_data"),
  // JSON stringified results
  status: varchar("status", { length: 20 }).notNull().default("processing"),
  // processing, success, error
  errorMessage: text("error_message"),
  executionTimeMs: integer("execution_time_ms"),
  createdAt: timestamp("created_at").notNull().defaultNow()
});
var insertQuerySchema = createInsertSchema(queries).pick({
  userQuestion: true
});
var salesOrders = pgTable("sales_orders", {
  orderId: varchar("order_id").primaryKey(),
  orderNumber: varchar("order_number").notNull(),
  customerName: text("customer_name").notNull(),
  orderDate: timestamp("order_date").notNull(),
  totalAmount: decimal("total_amount", { precision: 10, scale: 2 }).notNull(),
  status: varchar("status", { length: 20 }).notNull(),
  region: varchar("region", { length: 50 }),
  salesRep: text("sales_rep")
});
var workOrders = pgTable("work_orders", {
  workOrderId: varchar("work_order_id").primaryKey(),
  workOrderNumber: varchar("work_order_number").notNull(),
  description: text("description").notNull(),
  assignedTo: text("assigned_to"),
  status: varchar("status", { length: 20 }).notNull(),
  priority: varchar("priority", { length: 10 }).notNull(),
  scheduledDate: timestamp("scheduled_date"),
  completionDate: timestamp("completion_date"),
  department: varchar("department", { length: 50 })
});
var invoices = pgTable("invoices", {
  invoiceId: varchar("invoice_id").primaryKey(),
  invoiceNumber: varchar("invoice_number").notNull(),
  vendorName: text("vendor_name").notNull(),
  invoiceDate: timestamp("invoice_date").notNull(),
  dueDate: timestamp("due_date").notNull(),
  amount: decimal("amount", { precision: 10, scale: 2 }).notNull(),
  status: varchar("status", { length: 20 }).notNull(),
  paymentTerms: varchar("payment_terms", { length: 50 })
});
var inventoryItems = pgTable("inventory_items", {
  itemId: varchar("item_id").primaryKey(),
  itemCode: varchar("item_code").notNull(),
  itemName: text("item_name").notNull(),
  category: varchar("category", { length: 50 }),
  quantityOnHand: integer("quantity_on_hand").notNull(),
  unitPrice: decimal("unit_price", { precision: 10, scale: 2 }).notNull(),
  reorderLevel: integer("reorder_level"),
  warehouse: varchar("warehouse", { length: 50 })
});

// server/routes.ts
async function registerRoutes(app2) {
  app2.get("/api/dashboard/metrics", async (_req, res) => {
    try {
      const metrics = await storage.getDashboardMetrics();
      res.json(metrics);
    } catch (error) {
      console.error("Error fetching dashboard metrics:", error);
      res.status(500).json({ error: "Failed to fetch dashboard metrics" });
    }
  });
  app2.get("/api/query-templates", async (_req, res) => {
    try {
      const templates = await storage.getQueryTemplates();
      res.json(templates);
    } catch (error) {
      console.error("Error fetching query templates:", error);
      res.status(500).json({ error: "Failed to fetch query templates" });
    }
  });
  app2.get("/api/queries/recent", async (_req, res) => {
    try {
      const queries2 = await storage.getRecentQueries(5);
      res.json(queries2);
    } catch (error) {
      console.error("Error fetching recent queries:", error);
      res.status(500).json({ error: "Failed to fetch recent queries" });
    }
  });
  app2.get("/api/queries/history", async (_req, res) => {
    try {
      const queries2 = await storage.getQueryHistory();
      res.json(queries2);
    } catch (error) {
      console.error("Error fetching query history:", error);
      res.status(500).json({ error: "Failed to fetch query history" });
    }
  });
  app2.get("/api/queries/:id", async (req, res) => {
    try {
      const { id } = req.params;
      const query = await storage.getQuery(id);
      if (!query) {
        return res.status(404).json({ error: "Query not found" });
      }
      res.json(query);
    } catch (error) {
      console.error("Error fetching query:", error);
      res.status(500).json({ error: "Failed to fetch query" });
    }
  });
  app2.post("/api/queries", async (req, res) => {
    try {
      const validationResult = insertQuerySchema.safeParse(req.body);
      if (!validationResult.success) {
        return res.status(400).json({
          error: "Invalid request",
          details: validationResult.error.errors
        });
      }
      const { userQuestion } = validationResult.data;
      const query = await storage.createQuery({ userQuestion });
      res.json(query);
      processQueryAsync(query.id, userQuestion);
    } catch (error) {
      console.error("Error creating query:", error);
      res.status(500).json({ error: "Failed to create query" });
    }
  });
  async function processQueryAsync(queryId, userQuestion) {
    const startTime = Date.now();
    try {
      const recentQueries = await storage.getRecentQueries(5);
      const context = recentQueries.filter((q) => q.generatedSql).map((q) => ({
        question: q.userQuestion,
        sql: q.generatedSql
      }));
      const result = await generateSQLWithContext(userQuestion, context);
      let resultData = [];
      let errorMessage = null;
      try {
        resultData = await storage.executeSqlQuery(result.sql);
      } catch (execError) {
        console.error("SQL Execution Error:", execError);
        errorMessage = `Failed to execute query: ${execError instanceof Error ? execError.message : "Unknown error"}`;
      }
      const executionTimeMs = Date.now() - startTime;
      await storage.updateQuery(queryId, {
        generatedSql: result.sql,
        aiInterpretation: result.interpretation,
        resultData: errorMessage ? null : JSON.stringify(resultData),
        status: errorMessage ? "error" : "success",
        errorMessage,
        executionTimeMs
      });
    } catch (error) {
      console.error("Query Processing Error:", error);
      await storage.updateQuery(queryId, {
        status: "error",
        errorMessage: error instanceof Error ? error.message : "Failed to process query",
        executionTimeMs: Date.now() - startTime
      });
    }
  }
  app2.get("/api/ebs/sales-orders", async (_req, res) => {
    try {
      const orders = await storage.getSalesOrders();
      res.json(orders);
    } catch (error) {
      console.error("Error fetching sales orders:", error);
      res.status(500).json({ error: "Failed to fetch sales orders" });
    }
  });
  app2.get("/api/ebs/work-orders", async (_req, res) => {
    try {
      const orders = await storage.getWorkOrders();
      res.json(orders);
    } catch (error) {
      console.error("Error fetching work orders:", error);
      res.status(500).json({ error: "Failed to fetch work orders" });
    }
  });
  app2.get("/api/ebs/invoices", async (_req, res) => {
    try {
      const invoices2 = await storage.getInvoices();
      res.json(invoices2);
    } catch (error) {
      console.error("Error fetching invoices:", error);
      res.status(500).json({ error: "Failed to fetch invoices" });
    }
  });
  app2.get("/api/ebs/inventory", async (_req, res) => {
    try {
      const items = await storage.getInventoryItems();
      res.json(items);
    } catch (error) {
      console.error("Error fetching inventory items:", error);
      res.status(500).json({ error: "Failed to fetch inventory items" });
    }
  });
  const httpServer = createServer(app2);
  return httpServer;
}

// server/vite.ts
import express from "express";
import fs from "fs";
import path2 from "path";
import { createServer as createViteServer, createLogger } from "vite";

// vite.config.ts
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";
import path from "path";
import runtimeErrorOverlay from "@replit/vite-plugin-runtime-error-modal";
var vite_config_default = defineConfig({
  plugins: [
    react(),
    runtimeErrorOverlay(),
    ...process.env.NODE_ENV !== "production" && process.env.REPL_ID !== void 0 ? [
      await import("@replit/vite-plugin-cartographer").then(
        (m) => m.cartographer()
      ),
      await import("@replit/vite-plugin-dev-banner").then(
        (m) => m.devBanner()
      )
    ] : []
  ],
  resolve: {
    alias: {
      "@": path.resolve(import.meta.dirname, "client", "src"),
      "@shared": path.resolve(import.meta.dirname, "shared"),
      "@assets": path.resolve(import.meta.dirname, "attached_assets")
    }
  },
  root: path.resolve(import.meta.dirname, "client"),
  build: {
    outDir: path.resolve(import.meta.dirname, "dist/public"),
    emptyOutDir: true
  },
  server: {
    fs: {
      strict: true,
      deny: ["**/.*"]
    }
  }
});

// server/vite.ts
import { nanoid } from "nanoid";
var viteLogger = createLogger();
function log(message, source = "express") {
  const formattedTime = (/* @__PURE__ */ new Date()).toLocaleTimeString("en-US", {
    hour: "numeric",
    minute: "2-digit",
    second: "2-digit",
    hour12: true
  });
  console.log(`${formattedTime} [${source}] ${message}`);
}
async function setupVite(app2, server) {
  const serverOptions = {
    middlewareMode: true,
    hmr: { server },
    allowedHosts: true
  };
  const vite = await createViteServer({
    ...vite_config_default,
    configFile: false,
    customLogger: {
      ...viteLogger,
      error: (msg, options) => {
        viteLogger.error(msg, options);
        process.exit(1);
      }
    },
    server: serverOptions,
    appType: "custom"
  });
  app2.use(vite.middlewares);
  app2.use("*", async (req, res, next) => {
    const url = req.originalUrl;
    try {
      const clientTemplate = path2.resolve(
        import.meta.dirname,
        "..",
        "client",
        "index.html"
      );
      let template = await fs.promises.readFile(clientTemplate, "utf-8");
      template = template.replace(
        `src="/src/main.tsx"`,
        `src="/src/main.tsx?v=${nanoid()}"`
      );
      const page = await vite.transformIndexHtml(url, template);
      res.status(200).set({ "Content-Type": "text/html" }).end(page);
    } catch (e) {
      vite.ssrFixStacktrace(e);
      next(e);
    }
  });
}
function serveStatic(app2) {
  const distPath = path2.resolve(import.meta.dirname, "public");
  if (!fs.existsSync(distPath)) {
    throw new Error(
      `Could not find the build directory: ${distPath}, make sure to build the client first`
    );
  }
  app2.use(express.static(distPath));
  app2.use("*", (_req, res) => {
    res.sendFile(path2.resolve(distPath, "index.html"));
  });
}

// server/index.ts
var app = express2();
app.use(express2.json({
  verify: (req, _res, buf) => {
    req.rawBody = buf;
  }
}));
app.use(express2.urlencoded({ extended: false }));
app.use((req, res, next) => {
  const start = Date.now();
  const path3 = req.path;
  let capturedJsonResponse = void 0;
  const originalResJson = res.json;
  res.json = function(bodyJson, ...args) {
    capturedJsonResponse = bodyJson;
    return originalResJson.apply(res, [bodyJson, ...args]);
  };
  res.on("finish", () => {
    const duration = Date.now() - start;
    if (path3.startsWith("/api")) {
      let logLine = `${req.method} ${path3} ${res.statusCode} in ${duration}ms`;
      if (capturedJsonResponse) {
        logLine += ` :: ${JSON.stringify(capturedJsonResponse)}`;
      }
      if (logLine.length > 80) {
        logLine = logLine.slice(0, 79) + "\u2026";
      }
      log(logLine);
    }
  });
  next();
});
(async () => {
  const server = await registerRoutes(app);
  app.use((err, _req, res, _next) => {
    const status = err.status || err.statusCode || 500;
    const message = err.message || "Internal Server Error";
    res.status(status).json({ message });
    throw err;
  });
  if (app.get("env") === "development") {
    await setupVite(app, server);
  } else {
    serveStatic(app);
  }
  const port = parseInt(process.env.PORT || "5000", 10);
  server.listen({
    port,
    host: "0.0.0.0",
    reusePort: true
  }, () => {
    log(`serving on port ${port}`);
  });
})();